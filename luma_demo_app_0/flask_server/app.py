from flask import Flask, jsonify, request
from flask_cors import CORS
from dotenv import load_dotenv
import os
import json
import time
import requests

# Import worker and queen_worker modules
from queen_worker import QueenWorker
from worker import Worker

# Load environment variables
load_dotenv()

# Ensure OpenAI API key is set
openai_api_key = os.getenv("OPENAI_API_KEY")
if not openai_api_key:
    raise ValueError("OPENAI_API_KEY not found in environment variables")

# Get the OpenAI model from environment variable or use default
openai_model = os.getenv("OPENAI_MODEL", "gpt-3.5-turbo")
print(f"Using OpenAI model: {openai_model}")

app = Flask(__name__)
CORS(app)

# Initialize queen worker and worker
queen_worker = QueenWorker()
worker = Worker()


@app.route("/health", methods=["GET"])
def health_check():
    """
    Simple health check endpoint to verify the server is running
    """
    return jsonify({"status": "success", "message": "Flask server is running"})


@app.route("/weather", methods=["GET"])
def get_weather():
    try:
        # Get the OpenWeatherMap API key from environment
        api_key = os.getenv("OPENWEATHERMAP_API_KEY")
        if not api_key:
            return (
                jsonify(
                    {"status": "error", "message": "OpenWeatherMap API key not found"}
                ),
                400,
            )

        # City to get weather for
        city = "London"

        # Make request to OpenWeatherMap API
        url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
        response = requests.get(url)
        data = response.json()

        if response.status_code != 200:
            return (
                jsonify(
                    {
                        "status": "error",
                        "message": f"Error from OpenWeatherMap API: {data.get('message', 'Unknown error')}",
                    }
                ),
                400,
            )

        # Extract relevant weather information
        weather_description = data["weather"][0]["description"]
        temperature = data["main"]["temp"]
        humidity = data["main"]["humidity"]

        weather_info = f"Current weather in {city}: {weather_description}. Temperature: {temperature}Â°C. Humidity: {humidity}%."

        # Return successful response with weather data
        return jsonify({"status": "success", "weather": weather_info})
    except Exception as e:
        # Log the error for debugging
        print(f"Error fetching weather: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 400


@app.route("/company-types", methods=["GET"])
def get_company_types():
    """
    Returns a list of available company types and their associated roles
    """
    company_types = {
        "Construction": [
            "Construction Worker",
            "Project Manager",
            "Investor",
            "CEO",
            "Inventory Manager",
        ],
        "Technology": [
            "Developer",
            "Product Manager",
            "Investor",
            "CEO",
            "UX Designer",
        ],
        "Healthcare": [
            "Doctor",
            "Nurse",
            "Administrator",
            "Investor",
            "Medical Director",
        ],
        "Retail": [
            "Store Manager",
            "Sales Associate",
            "Inventory Manager",
            "Investor",
            "CEO",
        ],
    }

    return jsonify({"status": "success", "company_types": company_types})


@app.route("/construction-data", methods=["GET"])
def get_construction_data():
    """
    Route that returns construction company data and design restrictions generated by the queen worker.
    """
    try:
        # Generate data using QueenWorker
        company_data = queen_worker.generate_data()
        design_restrictions = queen_worker._generate_design_restrictions(company_data)

        # Get company type from query parameters with a default of 'Construction'
        company_type = request.args.get("company_type", "Construction")

        # If company type is provided, adjust the company data
        if company_type != "Construction":
            company_data["type"] = company_type
            # Add some company type specific data
            if company_type == "Technology":
                company_data["tech_stack"] = [
                    "Python",
                    "React",
                    "Node.js",
                    "AWS",
                    "MongoDB",
                ]
                company_data["product_categories"] = [
                    "SaaS",
                    "Mobile Apps",
                    "AI Solutions",
                ]
            elif company_type == "Healthcare":
                company_data["specialties"] = [
                    "Cardiology",
                    "Neurology",
                    "Pediatrics",
                    "Oncology",
                ]
                company_data["facilities"] = [
                    "Hospital",
                    "Clinic",
                    "Rehabilitation Center",
                ]
            elif company_type == "Retail":
                company_data["product_categories"] = [
                    "Clothing",
                    "Electronics",
                    "Home Goods",
                ]
                company_data["sales_channels"] = ["In-store", "Online", "Mobile App"]

        return jsonify(
            {
                "status": "success",
                "data": {
                    "company_data": company_data,
                    "design_restrictions": design_restrictions,
                },
            }
        )
    except Exception as e:
        print(f"Error generating construction data: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route("/generate-construction-ui", methods=["POST"])
def generate_construction_ui():
    """
    Route that accepts construction data and design restrictions and uses the worker
    to generate a UI based on them. Also accepts additional requirements based on user role.
    """
    try:
        data = request.get_json()
        company_data = data.get("company_data", {})
        design_restrictions = data.get("design_restrictions", {})
        additional_requirements = data.get("additional_requirements", "")

        if not company_data or not design_restrictions:
            return (
                jsonify(
                    {
                        "status": "error",
                        "message": "Both company data and design restrictions are required",
                    }
                ),
                400,
            )

        # Log the incoming data for debugging
        print(f"Generating UI for role: {additional_requirements}")

        # Enhanced prompt with role-specific requirements
        if additional_requirements:
            print(
                f"Generating role-specific UI with requirements: {additional_requirements}"
            )
            # Use the worker's generate_ui_with_data method to incorporate the additional requirements
            ui_result = worker.generate_ui_with_data(
                company_data, additional_requirements
            )
        else:
            # Standard UI generation
            ui_result = worker.generate_ui(company_data, design_restrictions)

        # Check if there's an error in the result
        if "error" in ui_result:
            print(f"Error in UI generation: {ui_result['error']}")
            return jsonify({"status": "error", "message": ui_result["error"]}), 500

        # Check if the required keys exist
        if "html" not in ui_result or "css" not in ui_result:
            error_msg = (
                f"Missing required data in UI result. Keys: {list(ui_result.keys())}"
            )
            print(error_msg)
            return jsonify({"status": "error", "message": error_msg}), 500

        return jsonify(
            {"status": "success", "html": ui_result["html"], "css": ui_result["css"]}
        )
    except Exception as e:
        print(f"Error generating construction UI: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500


if __name__ == "__main__":
    # Use port 5002 to avoid conflicts with the existing server
    app.run(debug=True, port=5002)
